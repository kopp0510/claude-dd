---
name: code-simplifier
description: 程式碼簡化專家，調用官方 code-simplifier agent 自動優化程式碼。專注於降低複雜度、提高可讀性、保持功能完整性。當需要簡化程式碼、改善程式碼結構、移除冗餘邏輯時自動啟用。
allowed-tools: Task, Read, Grep, Glob
---

# Code Simplifier

程式碼簡化專家 Skill，透過調用 Claude Code 官方的 code-simplifier agent，自動優化程式碼以降低複雜度、提高可讀性，同時保持功能完整性。

## Skill 定位

**這是官方 code-simplifier agent 的包裝器 (Wrapper)**

- **實作方式**：透過 `Task(subagent_type="code-simplifier", ...)` 調用官方 agent
- **Skill 職責**：提供自動觸發、互動式範圍確認、結構化報告產出
- **Agent 職責**：執行實際的程式碼簡化邏輯（由 Claude Code 官方維護）

**優點：**
- ✅ 重用官方 agent 的成熟邏輯（已優化且持續更新）
- ✅ Skill 代碼簡潔（僅負責介面層）
- ✅ 保持與官方功能同步（無需維護簡化邏輯）

## 觸發條件

**自動觸發時機：**
當使用者提到以下關鍵詞或場景時自動啟用：

**關鍵詞：**
- 「簡化程式碼」、「簡化這段程式碼」
- 「降低複雜度」、「減少複雜度」
- 「優化可讀性」、「提高可讀性」
- 「移除冗餘」、「移除重複」、「去除重複邏輯」
- 「改善命名」、「改善變數名稱」
- 「簡化條件」、「簡化邏輯」
- 「這段程式碼太複雜」、「這個函數太長」

**場景觸發：**
- 程式碼審查後提到需要簡化
- 重構前想先清理程式碼
- commit 前想整理程式碼
- 接手舊程式碼想先優化

**初始互動：**
啟動後詢問要簡化的範圍（檔案、目錄、或程式碼片段）。

## 工作流程

### Stage 1: 範圍確認（互動式）

**目標：** 確認要簡化的程式碼範圍和參數

#### Step 1: 詢問簡化目標

詢問使用者要簡化的目標：

**選項 A：特定檔案**
- 使用者提供檔案路徑
- 範例：`src/utils/validation.js`

**選項 B：特定目錄**
- 使用者提供目錄路徑
- 遞迴處理該目錄下的所有檔案
- 範例：`src/components/`

**選項 C：最近修改的檔案（預設）**
- 使用 `git diff --name-only` 找出最近修改的檔案
- 適合 commit 前的程式碼清理

**選項 D：程式碼片段**
- 使用者直接貼上要簡化的程式碼
- 適合快速測試或討論

#### Step 2: 可選參數詢問

**問題 1：是否包含測試檔案？**
- 預設：否（通常只簡化業務邏輯）
- 選項：是 / 否

**問題 2：簡化強度**
- **保守**：只處理明顯的問題，保留原有風格
- **標準**：平衡簡化和風格一致性（預設）
- **激進**：大幅重構，優先可讀性和最佳實踐

#### Step 3: 確認範圍

顯示將要處理的檔案清單，詢問使用者：
- 「以上 X 個檔案將被簡化，是否繼續？」
- 選項：繼續 / 調整範圍 / 取消

**退出條件：** 使用者確認範圍和參數。

---

### Stage 2: 調用官方 Agent（自動執行）

**目標：** 將工作委託給官方 code-simplifier agent

#### 準備 Agent 調用參數

根據 Stage 1 收集的資訊，準備 prompt：

```markdown
Task(
  subagent_type="code-simplifier",
  prompt=f"""
請簡化以下程式碼，專注於提高可讀性、一致性和可維護性，同時保留所有功能。

**目標範圍：**
{檔案清單或程式碼片段}

**簡化強度：** {保守/標準/激進}

**簡化重點：**
1. 降低圈複雜度（Cyclomatic Complexity）
2. 改善命名（變數、函數、類別）
3. 移除冗餘邏輯和重複程式碼
4. 提取重複邏輯為共用函數
5. 簡化條件邏輯（減少巢狀、使用 early return）
6. 改善程式碼結構和排版

**驗證要求：**
- 確保所有功能保持完整
- 如果有測試，必須全部通過
- 提供 Before/After 程式碼對比

**輸出格式：**
1. 簡化摘要（改進項目列表）
2. Before/After 對比（關鍵變更）
3. 測試驗證結果（如適用）
  """,
  description="簡化程式碼並優化可讀性"
)
```

#### 執行調用

使用 Task tool 調用官方 agent，等待完成。

**退出條件：** Agent 返回結果。

---

### Stage 3: 結果處理與報告（自動執行）

**目標：** 解讀 agent 輸出並產出友善的結構化報告

#### 解析 Agent 輸出

從 agent 的輸出中提取：
- 處理的檔案清單和統計
- 簡化的具體項目
- Before/After 程式碼對比
- 測試驗證結果

#### 產出結構化報告

產出以下格式的報告：

```markdown
# 程式碼簡化報告

## 📊 處理範圍

- **檔案數**：X 個
- **總程式碼行數**：Y 行
- **簡化程式碼行數**：Z 行
- **簡化強度**：{保守/標準/激進}

---

## ✅ 簡化項目

### 1. [檔案路徑:行號]
**改進內容**：降低圈複雜度（從 15 降至 8）

**Before：**
```語言
// 原始程式碼片段
```

**After：**
```語言
// 簡化後的程式碼片段
```

### 2. [檔案路徑:行號]
**改進內容**：移除重複邏輯，提取為共用函數

**Before：**
```語言
// 原始程式碼片段
```

**After：**
```語言
// 簡化後的程式碼片段
```

---

## 🔍 關鍵變更統計

| 指標 | Before | After | 改善 |
|-----|--------|-------|------|
| 圈複雜度 | 45 | 28 | ⬇ 38% |
| 函數平均長度 | 32 行 | 18 行 | ⬇ 44% |
| 巢狀深度 | 5 層 | 3 層 | ⬇ 40% |
| 重複程式碼行數 | 120 行 | 30 行 | ⬇ 75% |

---

## ✅ 驗證結果

- **測試狀態**：✅ 所有測試通過 (25/25)
- **功能完整性**：✅ 已驗證所有功能正常
- **程式碼品質**：✅ Linting 檢查通過

---

## 💡 建議

{如果有後續建議，例如：}
- 考慮為新提取的共用函數增加單元測試
- 可進一步將 X 函數拆分為更小的單元
- 建議為複雜邏輯增加註解說明
```

#### 錯誤處理

如果 agent 執行失敗，提供友善的錯誤訊息：

```markdown
## ❌ 簡化失敗

**錯誤原因**：{agent 返回的錯誤訊息}

**可能的解決方案**：
1. 確認檔案路徑是否正確
2. 確認檔案是否可被修改（沒有被 git lock）
3. 嘗試降低簡化強度（改為「保守」模式）
4. 縮小範圍（先處理單一檔案）

**需要協助嗎？**
可以嘗試：
- 「用保守模式簡化 [特定檔案]」
- 「先只簡化 [特定函數]」
```

**退出條件：** 報告產出完成或錯誤訊息已顯示。

---

## 使用範例

### 範例 1：自動模式（透過 Skill）

**使用者輸入：**
```
「這段程式碼太複雜了，幫我簡化」
```

**執行流程：**
1. **Skill 自動觸發** → 進入 Stage 1
2. **Stage 1**：詢問「要簡化哪些檔案？」
   - 使用者回答：「最近修改的檔案」
3. **Stage 1**：詢問「簡化強度？」
   - 使用者選擇：「標準」（預設）
4. **Stage 1**：顯示將處理 3 個檔案，確認？
   - 使用者：「繼續」
5. **Stage 2**：調用官方 code-simplifier agent
6. **Stage 3**：產出結構化報告

**優點：**
- 自動觸發，無需記住 agent 名稱
- 友善的互動式確認
- 結構化報告，易於理解

---

### 範例 2：手動模式（直接調用 Agent）

**使用者輸入：**
```
「用 code-simplifier 處理 src/utils/validation.js」
```

**執行流程：**
1. **直接調用官方 agent**（不經過 Skill）
2. Agent 執行簡化
3. 返回 Agent 原始輸出

**優點：**
- 快速執行，無額外互動
- 適合已知確切需求的情境

---

## Skill vs Agent 模式比較

| 特性 | Skill 模式（自動） | Agent 模式（手動） |
|-----|------------------|------------------|
| **觸發方式** | 關鍵詞自動觸發<br>（「簡化程式碼」） | 明確指定調用<br>（「用 code-simplifier」） |
| **範圍確認** | ✅ 互動式詢問 | ❌ 無額外互動 |
| **參數設定** | ✅ 詢問簡化強度 | ❌ 使用預設值 |
| **報告格式** | ✅ 結構化報告<br>（統計、對比、建議） | ⚠️ Agent 原始輸出 |
| **適用場景** | 新手、不確定範圍、想要報告 | 已知需求、快速執行 |
| **執行速度** | 較慢（多次互動） | 較快（直接執行） |

---

## 與其他 Skills 的差異

### vs. refactor-expert

| 特性 | code-simplifier | refactor-expert |
|-----|----------------|----------------|
| **核心目標** | 程式碼簡化、複雜度降低 | 架構重構、設計模式 |
| **適用範圍** | 函數級、檔案級 | 模組級、系統級 |
| **變更幅度** | 小幅優化（保留結構） | 大幅重構（改變結構） |
| **典型任務** | 移除冗餘、簡化條件 | 套用 SOLID 原則、引入設計模式 |
| **執行時間** | 快速（2-5 分鐘） | 較長（10-30 分鐘） |

**何時使用 code-simplifier：**
- 程式碼審查後的小幅清理
- Commit 前的程式碼整理
- 降低單一函數的複雜度
- 移除明顯的重複程式碼

**何時使用 refactor-expert：**
- 大規模架構重構
- 技術債減少
- 套用設計模式
- 模組解耦

### vs. performance-tuner

| 特性 | code-simplifier | performance-tuner |
|-----|----------------|------------------|
| **核心目標** | 可讀性和可維護性 | 執行效能和效率 |
| **評估指標** | 圈複雜度、程式碼行數 | 執行時間、記憶體使用 |
| **典型任務** | 簡化邏輯、改善命名 | 演算法優化、快取策略 |

**何時使用 code-simplifier：**
- 程式碼難以理解
- 函數過長或巢狀過深
- 重複邏輯過多

**何時使用 performance-tuner：**
- 效能瓶頸
- 回應時間過長
- 資源使用過高

---

## 簡化原則（由官方 Agent 執行）

以下原則由官方 code-simplifier agent 內建，Skill 無需實作：

### 1. 降低複雜度
- 減少圈複雜度（Cyclomatic Complexity）
- 減少巢狀深度（最多 3 層）
- 使用 early return 避免深層 if-else

### 2. 改善命名
- 使用有意義的變數名稱
- 函數名稱應清楚描述功能
- 避免縮寫和魔術數字

### 3. 移除冗餘
- 移除重複程式碼
- 提取共用邏輯為函數
- 移除未使用的變數和函數

### 4. 簡化邏輯
- 簡化布林表達式
- 合併重複的條件判斷
- 使用語言內建函數取代手寫迴圈

### 5. 保持功能完整
- 所有簡化必須保持功能不變
- 如有測試，必須全部通過
- 不改變公開 API 簽名

---

## 注意事項

### 1. 功能完整性保證
- **官方 agent 會確保**所有簡化不影響功能
- 如有測試，會自動執行驗證
- 如無測試，建議使用者手動驗證關鍵功能

### 2. 版本控制建議
- **建議在獨立分支執行簡化**
- 使用 git diff 審查變更
- 確認測試通過後再合併

### 3. 適用語言
- 官方 agent 支援所有主流語言
- 針對不同語言會應用對應的最佳實踐

### 4. 不適用場景
- **性能關鍵程式碼**：可能需要保留「看似複雜」但高效的寫法
- **Legacy 相容性**：需要保持特定寫法以相容舊版本
- **第三方程式碼**：不應修改外部函式庫或生成的程式碼

---

## 常見問題

### Q1: Skill 模式和手動調用 Agent 有什麼差異？
**A:**
- **Skill 模式**：自動觸發、互動式確認、結構化報告（適合新手）
- **Agent 模式**：手動調用、無額外互動、原始輸出（適合老手）

### Q2: 簡化會不會改變程式碼行為？
**A:**
不會。官方 code-simplifier agent 保證所有簡化保持功能完整性。如有測試，會自動驗證；如無測試，建議手動測試。

### Q3: 可以指定只簡化某個函數嗎？
**A:**
可以。在 Stage 1 選擇「程式碼片段」，貼上該函數的程式碼即可。

### Q4: 簡化強度的差異？
**A:**
- **保守**：只處理明顯問題，保留原有風格（適合重要程式碼）
- **標準**：平衡簡化和一致性（預設，適合大多數情況）
- **激進**：大幅重構，優先最佳實踐（適合新專案或重構中）

### Q5: 如何撤銷簡化？
**A:**
使用 git：
```bash
git checkout -- <檔案>  # 撤銷單一檔案
git reset --hard HEAD   # 撤銷所有變更（危險）
```

### Q6: 簡化會影響效能嗎？
**A:**
通常不會。官方 agent 專注可讀性，不會犧牲效能。如有效能要求，應先使用 performance-tuner 分析瓶頸。

---

## 總結

**code-simplifier Skill 的核心價值：**

1. **自動觸發**：關鍵詞即可啟動，無需記住 agent 名稱
2. **友善互動**：範圍確認和參數詢問，降低出錯機率
3. **結構化報告**：統一的報告格式，易於理解和審查
4. **官方品質**：完全重用官方 agent 的成熟邏輯
5. **保持同步**：隨官方更新自動獲得改進

**推薦使用時機：**
- ✅ 日常程式碼清理和優化
- ✅ Code review 後的改進
- ✅ Commit 前的程式碼整理
- ✅ 接手舊專案的初步優化

**不推薦使用時機：**
- ❌ 大規模架構重構 → 使用 `refactor-expert`
- ❌ 效能瓶頸優化 → 使用 `performance-tuner`
- ❌ 第三方程式碼修改 → 不應修改外部程式碼
